using System;
using System.Collections.Generic;
using Konamiman.Z80dotNet;
using Xunit;

namespace SomeCompiler.Z80.Tests;

public class ExternalToolsComparisonTest
{
    [Fact]
    public void Simple_HL_load_should_work_in_simulator()
    {
        // This is the exact same binary generated by pasmo for:
        // LD SP, 0xFF00
        // LD HL, 42
        // HALT
        byte[] simpleBinary = { 0x31, 0x00, 0xFF, 0x21, 0x2A, 0x00, 0x76 };
        
        var cpu = new Z80Processor();
        cpu.Reset();
        cpu.Memory.SetContents(0x8000, simpleBinary);
        cpu.Registers.PC = 0x8000;
        
        // Execute until HALT
        const int maxSteps = 100;
        for (int i = 0; i < maxSteps; i++)
        {
            if (cpu.Memory[cpu.Registers.PC] == 0x76) // HALT instruction
                break;
            cpu.ExecuteNextInstruction();
        }
        
        // Check final state
        var hl = (cpu.Registers.H << 8) | cpu.Registers.L;
        var sp = (ushort)cpu.Registers.SP;
        
        Console.WriteLine($"Final HL: {hl} (expected: 42)");
        Console.WriteLine($"Final SP: 0x{sp:X4} (expected: 0xFF00)");
        Console.WriteLine($"PC at HALT: 0x{cpu.Registers.PC:X4}");
        
        Assert.Equal(42, hl);
        Assert.Equal(0xFF00, sp);
    }
    
    [Fact]
    public void Compare_our_generated_code_structure()
    {
        // Let's create a minimal version of our function call pattern
        // and see if the simulator handles it correctly
        
        var program = new List<byte>();
        
        // LD SP, 0xFF00
        program.AddRange(new byte[] { 0x31, 0x00, 0xFF });
        
        // PUSH 42 (simulate parameter passing)
        program.AddRange(new byte[] { 0x21, 0x2A, 0x00 }); // LD HL, 42
        program.AddRange(new byte[] { 0xE5 });             // PUSH HL
        
        // Now try to read it back from stack
        program.AddRange(new byte[] { 0xE1 });             // POP HL
        
        // HALT
        program.Add(0x76);
        
        var cpu = new Z80Processor();
        cpu.Reset();
        cpu.Memory.SetContents(0x8000, program.ToArray());
        cpu.Registers.PC = 0x8000;
        
        // Execute until HALT
        const int maxSteps = 100;
        for (int i = 0; i < maxSteps; i++)
        {
            if (cpu.Memory[cpu.Registers.PC] == 0x76) // HALT
                break;
            cpu.ExecuteNextInstruction();
        }
        
        var hl = (cpu.Registers.H << 8) | cpu.Registers.L;
        Console.WriteLine($"After PUSH/POP cycle, HL: {hl} (should be 42)");
        
        Assert.Equal(42, hl);
    }
}
